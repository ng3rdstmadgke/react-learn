# 12. データの変更

- https://nextjs.org/learn/dashboard-app/mutating-data

## React Server Actions

- [サーバーアクションでのフォームの作り方 | NEXT.js](https://nextjs.org/docs/app/guides/forms)
- [サーバーアクションのセキュリティについて | NEXT.js](https://nextjs.org/blog/security-nextjs-server-components-actions)
  - https://notebooklm.google.com/notebook/9d283703-41c4-423e-aedb-beb9fe685f85

React Server Actionsを使用すると、サーバー上で直接非同期コードを実行できます。  
データの変更のためにAPIエンドポイントを作成する必要がなくなります。代わりに、サーバー上で実行され、クライアントまたはサーバーコンポーネントから呼び出せる非同期関数を記述します。

ウェブアプリケーションは様々な脅威に対して脆弱であるため、セキュリティは最優先事項です。  
Server Actionsには、暗号化されたクロージャ、厳格な入力チェック、エラーメッセージのハッシュ化、ホスト制限などの機能が含まれており、これらが連携してアプリケーションのセキュリティを大幅に強化します。


## Server Actions でフォームを利用する

Reactでは、`<form>` 要素の `action` 属性を使用してアクションを呼び出すことができます。このaction属性には、キャプチャされたデータを含むネイティブの [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) オブジェクトが自動的に渡されます。



```ts
// Server Component
export default function Page() {
  // Action
  async function create(formData: FormData) {
    'use server';
 
    // Logic to mutate data...
  }
 
  // Invoke the action using the "action" attribute
  return <form action={create}>...</form>;
}
```

サーバーコンポーネント内で Server Actions を呼び出す利点は、クライアント側でJavaScriptの読み込みが完了していなくてもフォームが機能するということです。


## Server Actions と Next.js

Server Actions は [Next.js のキャッシュ機能](https://nextjs.org/docs/app/guides/caching)とも深く連携しています。Server Actions 経由でフォームが送信された場合、アクションでデータを変更できるだけでなく、`revalidatePath` や `revalidateTag` といったAPIを使用して関連するキャッシュを再検証することも可能です。

## Invoiceの作成

### 1. 新しいルートとフォームの作成


`/dashboard/invoices` に新しいルート `/create` を追加します。


```bash
mkdir -p app/dashboard/invoices/create
touch app/dashboard/invoices/create/page.tsx
```


`/app/dashboard/invoices/create/page.tsx`
```tsx
import Form from '@/app/ui/invoices/create-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchCustomers } from '@/app/lib/data';
 
export default async function Page() {
  const customers = await fetchCustomers();
 
  return (
    <main>
      <Breadcrumbs
        breadcrumbs={[
          { label: 'Invoices', href: '/dashboard/invoices' },
          {
            label: 'Create Invoice',
            href: '/dashboard/invoices/create',
            active: true,
          },
        ]}
      />
      <Form customers={customers} />
    </main>
  );
}
```

ページはサーバーコンポーネントであり、`customers` データを取得して `<Form>` コンポーネントに渡します。


フォームの実態は `/app/ui/invoices/breadcrumbs` 


![img](img/12_form.png)

### 2. Server Actions を作成する

フォームが送信されたときに呼び出されるサーバーアクションを定義します。

`/app/lib/actions.ts` を作成し、 `'use server';` を指定します。  
※ [`'use server'`](https://react.dev/reference/rsc/use-server) はクライアント側から呼び出せるサーバー側の関数をマークするために利用します。

`'use server'` を追加することで、ファイル内のエクスポートされた関数をすべてサーバーアクションとしてマークします。  
れらのサーバー関数は、クライアントコンポーネントやサーバーコンポーネントでインポートして使用できます。  
このファイルに含まれる未使用の関数は、最終的なアプリケーションバンドルから自動的に削除されます。

※ 関数内に `'use server'` を追加することで、サーバーコンポーネント内に直接サーバーアクションを記述することも可能です。


`/app/lib/actions.ts`
```ts
'use server';
 
export async function createInvoice(formData: FormData) {

}
```


次に、 `<Form>` コンポーネント内で、 `createInvoice` をインポートします。`<form>` 要素に `action` 属性を追加し、 `createInvoice` アクションを呼び出します。

`/app/ui/invoices/create-form.tsx`
```tsx
// ...
import { createInvoice } from '@/app/lib/actions';  // 追加

export default function Form({ customers }: { customers: CustomerField[] }) {
  return (
    <form action={createInvoice}> {/* action属性を追加 */}
```

### 補足: action属性に関して

HTMLではaction属性にはフォームの送信先URLを指定しますが、Reactでは `action` 属性は特別なプロパティとみなされており、アクション(関数)を指定することができます。  
サーバーアクションはバックグラウンドで `POST` APIエンドポイントを作成するため、サーバーアクションを使用する際にAPIエンドポイントを手動で作成する必要はありません。  

### 3. `formData` からデータを抽出する

`FormData` の [`get` メソッド](https://developer.mozilla.org/en-US/docs/Web/API/FormData/get) でフォームのデータを取得します。  
※ まとめて取得したい場合は [`entries` メソッド](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries) も利用できます。


`/app/lib/actions.ts`
```ts
'use server';
 
export async function createInvoice(formData: FormData) {
  // FormData: https://developer.mozilla.org/ja/docs/Web/API/FormData
  const rawFormData = {
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  }
  console.log('Raw Form Data:', rawFormData);  // サーバー側で実行されるのでターミナル側にログが出力されます
}
```


### 4. データのバリデーション

フォームをデータベースに送信する前にバリデーションを行います。  
請求書テーブルのデータ型は `/app/lib/definitions.ts` の `Invoice` として定義されています。

`/app/lib/definitions.ts`
```ts
export type Invoice = {
  id: string; // Will be created on the database
  customer_id: string;
  amount: number; // Stored in cents
  status: 'pending' | 'paid';
  date: string;
};
```

#### 型のバリデーションと強制

DBの `amount` は `number` 型ですが、フォームの `amount` は `string` 型になっていることがわかります。

`/app/lib/actions.ts`
```ts
console.log('Type of amount:', typeof rawFormData.amount);  // Type of amount: string
```

TypeScriptでは型の検証と強制には [Zod](https://zod.dev/) を利用します。  

`/app/lib/actions.ts`
```ts
'use server';

import { z } from 'zod';

const FormSchema = z.object({
  id: z.string(),
  customerId: z.string(),  // https://zod.dev/api?id=strings
  amount: z.coerce.number(),  // 入力データを適切な型に強制変換 (https://zod.dev/api?id=coercion)
  status: z.enum(['pending', 'paid']),  // https://zod.dev/api?id=enums
  date: z.string(),
})

// idとdateはサーバー側で生成するため、フォームからは受け取らない (https://zod.dev/api?id=omit)
const CreateInvoice = FormSchema.omit({id: true, date: true})

export async function createInvoice(formData: FormData) {
  // FormData: https://developer.mozilla.org/ja/docs/Web/API/FormData
  const {customerId, amount, status} = CreateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  })
  // 浮動小数点エラーを排除し精度を高めるためにデータベースに通貨値をセント単位で保存
  const amountInCents = amount * 100;
  // 請求書の作成日として「YYYY-MM-DD」の形式で新しい日付を作成します
  const data = new Date().toISOString().split("T")[0];
   console.log({customerId, amountInCents, status, data});  // {customerId: '3958dc9e-712f-4377-85e9-fec4b6a6442a', amountInCents: 2222200, status: 'pending', data: '2025-10-09'}
}
```

### 5. データベースにデータを挿入する

データベースに必要な値がすべて揃ったので、新しい請求書をデータベースに挿入し、変数を渡す SQL クエリを作成できます。

`/app/lib/actions.ts`
```ts
'use server';

import { z } from 'zod';
import postgres from 'postgres';

const sql = postgres(process.env.POSTGRES_URL!, { ssl: false });

// ...

export async function createInvoice(formData: FormData) {
  // ...

  await sql`
    INSERT INTO invoices (customer_id, amount, status, date)
    VALUES (${customerId}, ${amountInCents}, ${status}, ${data})
  `;
}
```


### 6. 再検証してリダイレクト

Next.js には、ルートセグメントをユーザーのブラウザに一定期間保存するクライアント側ルーターキャッシュがあります。このキャッシュは、プリフェッチと併用することで、ユーザーがルート間を素早く移動できるようにし、サーバーへのリクエスト数を削減します。

請求書ルートに表示されるデータを更新するため、このキャッシュをクリアしてサーバーへの新しいリクエストをトリガーする必要があります。これは、revalidatePathNext.jsの関数を使用して実行できます。

`/app/lib/actions.ts`
```ts
// ...

import { revalidatePath } from 'next/cache';

// ...

export async function createInvoice(formData: FormData) {
  // ...

  revalidatePath('/dashboard/invoices');  // キャッシュをクリアして、請求書一覧ページを再検証・データを再取得
}
```


データベースが更新されると、/dashboard/invoicesパスが再検証され、サーバーから最新のデータが取得されます。

この時点で、ユーザーを元のページに戻すリダイレクトも行います


`/app/lib/actions.ts`
```ts
// ...

import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';

// ...

export async function createInvoice(formData: FormData) {
  // ...

  revalidatePath('/dashboard/invoices');  // キャッシュをクリアして、請求書一覧ページを再検証・データを再取得
  redirect('/dashboard/invoices');  // 請求書一覧ページにリダイレクト
}
```


## Invoiceの更新

### 1. `invoices/` 配下に動的ルートセグメント(`[id]`)を作成する

Next.js では、正確なセグメント名がわからず、データに基づいてルートを作成したい場合に、 動的ルートセグメントを作成できます。  
フォルダ名を角括弧で囲むことで、動的ルートセグメントを作成できます。例えば`[id]` や `[post]` などです。


- [Dynamic Route Segments | NEXT.js](https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes)



```bash
mkdir -p "app/dashboard/invoices/[id]/edit"
touch "app/dashboard/invoices/[id]/edit/page.tsx"
```

`<Table>` コンポーネントには、テーブル レコードから請求書を受け取るボタン `<UpdateInvoice />` があることに注目してください

`/app/ui/invoices/table.tsx`
```tsx
export default async function InvoicesTable({
  query,
  currentPage,
}: {
  query: string;
  currentPage: number;
}) {
  return (
    // ...
    <td className="flex justify-end gap-2 whitespace-nowrap px-6 py-4 text-sm">
      <UpdateInvoice id={invoice.id} />  {/* <- これ */}
      <DeleteInvoice id={invoice.id} />
    </td>
    // ...
  );
}

```

`<UpdateInvoice />` コンポーネントに移動し、`id` プロパティを受け入れるよう `href` にを更新します。
`<UpdateInvoice />` コンポーネントに移動し、`Link` の `href` を `id` プロパティを受け入れるように更新します。動的なルートセグメントへのリンクにはテンプレートリテラルを使用できます:

`/app/ui/invoices/buttons.tsx`
```tsx
import { PencilIcon, PlusIcon, TrashIcon } from '@heroicons/react/24/outline';
import Link from 'next/link';
 
// ...
 
export function UpdateInvoice({ id }: { id: string }) {
  return (
    <Link
      href={`/dashboard/invoices/${id}/edit`}  // idを含めたパスに修正
      className="rounded-md border p-2 hover:bg-gray-100"
    >
      <PencilIcon className="w-5" />
    </Link>
  );
}
```

### 2. 指定された `id` の請求書を読み込む

URLのパスから `id` を取得し、その `id` で対象の `invoice` を取得します。  
取得した `invoice` の情報をデフォルト値として編集フォームを描画します。

`/app/dashboard/invoices/[id]/edit/page.tsx`
```tsx
import Form from "@/app/ui/invoices/edit-form";
import Breadcrumbs from "@/app/ui/invoices/breadcrumbs";
import { fetchInvoiceById, fetchCustomers } from "@/app/lib/data";

export default async function Page(props: {params: Promise<{id: string}>}) {
  const params = await props.params;
  const id = params.id;
  // フォームの初期値として請求書データと顧客データを取得
  const [invoice, customers] = await Promise.all([
    fetchInvoiceById(id),
    fetchCustomers()
  ])
  return (
    <main>
      <Breadcrumbs
        breadcrumbs={[
          { label: 'Invoices', href: '/dashboard/invoices' },
          {
            label: 'Edit Invoice',
            href: '/dashboard/invoices/${id}/edit',
            active: true,
          },

        ]}
      />
      {}
      <Form invoice={invoice} customers={customers} />
    </main>
  )
}
```

![img](img/12_edit_form.png)


### 3. サーバーアクションに渡す

データベースを更新するためのサーバーアクションを定義します。

`/app/lib/actions.ts`
```tsx
// Use Zod to update the expected types
const UpdateInvoice = FormSchema.omit({ id: true, date: true });
 
// ...
 
export async function updateInvoice(id: string, formData: FormData) {
  // フォームから送信されたデータを検証
  // FormData: https://developer.mozilla.org/ja/docs/Web/API/FormData
  const { customerId, amount, status } = UpdateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  });
 
  const amountInCents = amount * 100;
 
  await sql`
    UPDATE invoices
    SET customer_id = ${customerId}, amount = ${amountInCents}, status = ${status}
    WHERE id = ${id}
  `;
 
  revalidatePath('/dashboard/invoices');  // キャッシュをクリアして、請求書一覧ページを再検証・データを再取得
  redirect('/dashboard/invoices');  // 請求書一覧ページにリダイレクト
}
```

最後に、サーバーアクションをコンポーネントの `<form>` の `action` に指定しますが、
サーバーアクションの `id` 引数は以下のような形式で渡すことはできません。

```tsx
// Passing an id as argument won't work
<form action={updateInvoice(id)}>
```

代わりに、JavaScriptの `Function.prototype.bind()` 関数を使用して `id` がすでに設定された `updateInvoice()` を生成することができます。


`/app/ui/invoices/edit-form.tsx`
```tsx
'use client';
// ...
import { updateInvoice } from '@/app/lib/actions';  // 追加

export default function EditInvoiceForm({ invoice, customers, }: { invoice: InvoiceForm; customers: CustomerField[]; }) {

  // updateInvoice()の第一引数(id)に invoice.id を指定した関数を生成
  const updateInvoiceWithId = updateInvoice.bind(null, invoice.id);

  return (
    <form action={updateInvoiceWithId}>  {/* form の action に請求書を更新する関数を指定 */}
    {/* ... */}
    </form>
  )
}
```


#### `Function.prototype.bind()` とは

- [Function.prototype.bind() | MDN](https://nextjs.org/learn/dashboard-app/mutating-data)

`bind()` 関数は元の関数の「 `this` キーワード」と「引数」を設定した新しい関数を生成します。  
いわゆる **カリー化** みたいなことができる


- シグネチャ
`bind(thisArg, arg1, arg2, ... argN)`
- 引数
  - `thisArg`
  関数内で `this` を利用したときに参照されるオブジェクトを指定します。  
  `null` `undefined` を指定するとグローバルオブジェクトとなります。
  - `arg1, ..., argN`
  元の関数の引数を一部または全部指定できます
- 戻り値
  `this` の値と初期の引数が設定された関数のコピー


例1: 引数の一部を指定する

```js
function product (a, b) {
    return a * b;
}

console.log(product(5, 4)) // 20

var double = product.bind(null, 2)  // productの第一引数に2を指定した新しい関数を生成

console.log(double(5))  // 10
```

例2: 任意の this を指定する

```js

const module = {
  x: 42,
  getX() {
    return this.x;
  }
}

var unboundGetX = module.getX;
console.log(unboundGetX()); // undefined (関数内の this がグローバルオブジェクトなので)

var boundGetX = module.getX.bind(module)
console.log(boundGetX())  // 42 (関数内の this が module オブジェクトなので)
```


## Invoiceの削除

invoiceを削除するサーバーアクションを定義します。


`/app/lib/actions.ts`
```ts
export async function deleteInvoice(id: string) {
  await sql`DELETE FROM invoices WHERE id = ${id}`;
  revalidatePath('/dashboard/invoices');  // キャッシュをクリアして、請求書一覧ページを再検証・データを再取得
}
```

サーバーアクションを使用して請求書を削除するには、削除ボタンを `<form>` 要素で囲み、 `bind` を使用して `id` をサーバーアクションに渡します：

`/app/ui/invoices/buttons.tsx`
```tsx
import { deleteInvoice } from '@/app/lib/actions';
 
// ...
 
export function DeleteInvoice({ id }: { id: string }) {
  // deleteInvoice()の第一引数(id)に invoice.id を指定した関数を生成
  const deleteInvoiceWithId = deleteInvoice.bind(null, id);

  return (
    <form action={deleteInvoiceWithId}>
      <button type="submit" className="rounded-md border p-2 hover:bg-gray-100">
        <span className="sr-only">Delete</span>
        <TrashIcon className="w-4" />
      </button>
    </form>
  );
}
```
